// Example 9: Using predicates for abstract specifications
// This demonstrates predicate definitions and folding/unfolding

// Predicate for a valid range
predicate valid_range(x: Int, y: Int) {
  0 <= x && x <= y
}

// Method using the predicate
method compute_range(a: Int, b: Int) returns (size: Int)
  requires valid_range(a, b)
  ensures size == b - a
  ensures size >= 0
{
  unfold valid_range(a, b)
  size := b - a
}

// Predicate for sorted array segment
predicate sorted_segment(a: Seq[Int], from: Int, to: Int) {
  0 <= from && from <= to && to <= |a| &&
  forall i: Int, j: Int :: from <= i && i < j && j < to ==> a[i] <= a[j]
}

// Method to check if an array is sorted
method is_sorted(a: Seq[Int]) returns (result: Bool)
  requires |a| > 0
  ensures result == (forall i: Int, j: Int :: 0 <= i && i < j && j < |a| ==> a[i] <= a[j])
{
  var i: Int := 0
  result := true
  
  while (i < |a| - 1 && result)
    invariant 0 <= i && i < |a|
    invariant result ==> forall k: Int, l: Int :: 0 <= k && k < l && l <= i ==> a[k] <= a[l]
  {
    if (a[i] > a[i + 1]) {
      result := false
    }
    i := i + 1
  }
}

// Predicate for array bounds
predicate in_bounds(a: Seq[Int], i: Int) {
  0 <= i && i < |a|
}

// Safe array access using predicate
method safe_get(a: Seq[Int], i: Int) returns (val: Int)
  requires in_bounds(a, i)
  ensures val == a[i]
{
  unfold in_bounds(a, i)
  val := a[i]
}

// Test methods
method test_predicates()
{
  // Test valid_range
  var range_size: Int := compute_range(0, 10)
  assert range_size == 10
  
  // Test is_sorted
  var sorted_arr: Seq[Int] := Seq(1, 2, 3, 4, 5)
  var is_sorted_result: Bool := is_sorted(sorted_arr)
  assert is_sorted_result
  
  var unsorted_arr: Seq[Int] := Seq(5, 3, 1, 4, 2)
  var is_unsorted_result: Bool := is_sorted(unsorted_arr)
  assert !is_unsorted_result
  
  // Test safe access
  var arr: Seq[Int] := Seq(10, 20, 30)
  var value: Int := safe_get(arr, 1)
  assert value == 20
}
