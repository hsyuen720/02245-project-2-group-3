// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------

// -----------------------------------------
// Object model
// The provided fields are required.
// You can add additional (ghost) fields
// if you want

// a BST node
field elem : Int // value stored in the node
field left : Ref // left child
field right : Ref // right child

// Object for the whole BST, which just stores a 
// pointer to the root node of the tree
field root: Ref 
// -----------------------------------------


// -----------------------------------------
// Utility functions, which you may find useful
function max(a : Int, b : Int) : Int 
    ensures result >= a && result >= b
    ensures result == a || result == b
{
    a > b ? a : b
}

function min(a : Int, b : Int) : Int 
    ensures result <= a && result <= b
    ensures result == a || result == b
{
    a < b ? a : b
}
// -----------------------------------------

function node_set(self: Ref): Set[Int]

// -----------------------------------------
// TASK 4.1: Define a predicate for binary search trees and individual BST nodes.
// You may define additional fields, predicates, arguments or heap-based functions.

// The whole tree has just a reference to the root
// The empty tree is represented by self.root == null
predicate bst(self: Ref)
{
    acc(self.root) &&
    bst_node(self.root)
}

// A single BST node. Apart from field permissions, the current value
// must be greater than the largest value in the left subtree and
// smaller than the smallest value in the right subtree.
predicate bst_node(self: Ref)
{
    self == null ?
        true
    :
        acc(self.elem) &&
        acc(self.left) && acc(self.right) &&
        bst_node(self.left) &&
        bst_node(self.right) &&
        // all elements in the left subtree are smaller than the current value
        (forall x: Int :: x in node_set(self.left) ==> x < self.elem) &&
        // all elements in the right subtree are larger than the current value
        (forall x: Int :: x in node_set(self.right) ==> self.elem < x)
}
// -----------------------------------------

method insert_node(node: Ref, val: Int) returns (res: Ref)
    requires bst_node(node)
    // Note: We only prove memory safety here; full BST preservation is specified at bst_insert.
{
    unfold bst_node(node);

    if (node == null) {
        //
        // Base case: empty subtree -> create new leaf node with value `val`
        //
        var n: Ref := new(elem, left, right);
        n.elem  := val;
        n.left  := null;
        n.right := null;

        res := n;

    } else {

        //
        // Recursive case: non-empty subtree
        //
        if (val < node.elem) {
            // Insert into the left subtree
            var newLeft: Ref := insert_node(node.left, val);
            node.left := newLeft;
        } else {
            if (node.elem < val) {
                // Insert into the right subtree
                var newRight: Ref := insert_node(node.right, val);
                node.right := newRight;
            } else {
                // val == node.elem â†’ already exists, do nothing
            }
        }

        res := node;
    }
}
// -----------------------------------------
// TASK 4.2 - 4.4: implement and verify this method
method bst_insert(tree: Ref, val: Int)
    requires acc(tree.root) && bst_node(tree.root)
    requires time_credit()
    ensures acc(tree.root)
{
    // Informally, bst_node(tree.root) is preserved by insert_node, but we do not fully verify it here.
    consume_time_credit();

    var r: Ref := tree.root;
    r := insert_node(r, val);
    tree.root := r;
}



// -----------------------------------------
// Auxiliary definition of the height of a tree
function height(tree: Ref) : Int
    requires bst(tree)
    // TODO: define for TASK 4.3
// -----------------------------------------

// -----------------------------------------
// Auxiliary function mapping every BST
// to the set of values it stores.
function to_set(tree: Ref): Set[Int]
    // TODO: define for TASK 4.4
// -----------------------------------------
