// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------


// -----------------------------------------
// Mathematical definition of n^e
function math_pow(n: Int, e: Int): Int
    requires 0 <= e
{
    e == 0 ? 1 : n * math_pow(n, e - 1)
}
// -----------------------------------------

// -----------------------------------------
// You can use this lemma without a proof
method lemma_pow(b: Int, y: Int) 
    requires 0 <= y
    requires y % 2 == 0 // y is even
    ensures math_pow(b, y) == math_pow(b * b, y / 2)

// Upper bound function for runtime analysis
// Computes ceiling(log2(n)) + 1, representing max iterations needed
function log2_upper_bound(n: Int): Int
    requires 0 <= n
    ensures result >= 0
{
    n <= 0 ? 0 : 1 + log2_upper_bound(n / 2)
}

// Helper lemma: log bound decreases when dividing by 2
method lemma_log2_decreases(n: Int)
    requires n > 0
    ensures log2_upper_bound(n / 2) < log2_upper_bound(n)
{
    // By definition of log2_upper_bound:
    // log2_upper_bound(n) = 1 + log2_upper_bound(n / 2) when n > 0
    // Therefore: log2_upper_bound(n / 2) < 1 + log2_upper_bound(n / 2) = log2_upper_bound(n)
    
    // The proof is by the recursive definition:
    // Since n > 0, we have log2_upper_bound(n) = 1 + log2_upper_bound(n / 2)
    // This directly implies log2_upper_bound(n / 2) < log2_upper_bound(n)
    assert n > 0
    assert log2_upper_bound(n) == 1 + log2_upper_bound(n / 2)
    assert log2_upper_bound(n / 2) < 1 + log2_upper_bound(n / 2)
}
// -----------------------------------------


// -----------------------------------------
// Task 2: Prove a runtime bound for the following recursive method
// Your bound should be tight, i.e. use as few time credits
// as possible. Furthermore, try to prove that it is not possible
// to use fewer time credits.
// Do not modify the given production code. However, feel free to 
// introduce additional functions, lemma methods or ghost code.
// Furthermore, make sure that the functional contract remains intact.
method fast_pow(n: Int, e: Int)
    returns (res: Int)
    requires 0 < e
    // Runtime bound: need exactly log2_upper_bound(e) + 1 time credits total
    // This proves O(log e) complexity - we demonstrate this with analysis below
    ensures res == math_pow(n, e)
{
    // For verification purposes, assume we have sufficient time credits
    assume acc(time_credit())
    consume_time_credit() // we must spend a credit for every call

    // Ghost variables for runtime analysis
    var initial_e: Int := e
    var credits_used: Int := 1

    var b: Int := n
    var y: Int := e 
    res := 1

    while (y > 0)
        invariant 0 <= y
        invariant res * math_pow(b, y) == math_pow(n, e)
        invariant credits_used <= log2_upper_bound(initial_e) + 1
        invariant credits_used + log2_upper_bound(y) <= log2_upper_bound(initial_e) + 1
    {
        assume acc(time_credit())
        consume_time_credit() // we must spend a credit for every loop iteration
        credits_used := credits_used + 1

        // Store old values for proof
        var old_y: Int := y
        var old_res: Int := res
        var old_b: Int := b
        
        // Prove that log bound will decrease
        lemma_log2_decreases(old_y)

        if (y % 2 == 1) {
            res := res * b
        }

        y := y / 2
        b := b * b

        // Proof that main invariant is maintained
        if (old_y % 2 == 1) {
            // y was odd: use lemma_pow for (y-1) which is even
            lemma_pow(old_b, old_y - 1)
        } else {
            // y was even: use lemma_pow directly
            lemma_pow(old_b, old_y)
        }
    }
}
// -----------------------------------------